#pragma shader_stage(compute)
#extension GL_ARB_separate_shader_objects: enable

#define KernalSize 16
//#include "lib/util"

//#include "lib/camera_property"

layout (local_size_x = 16, local_size_y = 16) in;

// Normal filtered anti-aliasing.
// See http://blenderartists.org/forum/showthread.php?209574-Full-Screen-Anti-Aliasing-(NFAA-DLAA-SSAA)
// and http://www.gamedev.net/topic/580517-nfaa---a-post-process-anti-aliasing-filter-results-implementation-details/
// Copyright Styves, Martinsh
// Modified by Sagrista, Toni

layout(binding = 0) uniform CameraProperty_ {
    float scale;
    uint cap1;
    uint cap2;
    uint cap3;
};


layout (binding = 1) uniform sampler2D inputImage;
layout (binding = 2) restrict writeonly uniform image2D outputImage;


const float fScale = 1.25f;
const float weights[5] = {
    0.285f, 0.305f, 0.224f, 0.122f, 0.064f
};

//const vec2 kernal[KernalSize] = {
//    vec2(1, 0),
//    vec2(0.923861, 0.382728),
//    vec2(0.707073, 0.707141),
//    vec2(0.382639, 0.923898),
//    vec2(0, 1),
//    vec2(-0.382728, 0.923861),
//    vec2(-0.707141, 0.707073),
//    vec2(-0.923898, 0.382639),
//    vec2(-1, 0),
//    vec2(-0.923861, -0.382728),
//    vec2(-0.707073, -0.707141),
//    vec2(-0.382639, -0.923898),
//    vec2(0, -1),
//    vec2(0.382728, -0.923861),
//    vec2(0.707141, -0.707073),
//    vec2(0.923898, -0.382639),
//};

float lumRGB(vec4 v) {
    return v.a * dot(v.rgb, vec3(0.212, 0.716, 0.072));
}


vec4 fxaa(sampler2D tex, ivec2 srcPos, vec2 texCoord, vec2 unitStep) {
    vec3 rgbNW = texture(tex, texCoord + vec2(-1.0f, -1.0f) * unitStep).rgb;
    vec3 rgbNE = texture(tex, texCoord + vec2( 1.0f, -1.0f) * unitStep).rgb;
    vec3 rgbSW = texture(tex, texCoord + vec2(-1.0f,  1.0f) * unitStep).rgb;
    vec3 rgbSE = texture(tex, texCoord + vec2( 1.0f,  1.0f) * unitStep).rgb;

    vec4 center = texelFetch(tex, srcPos, 0);
    vec3 rgbM = center.rgb;

    vec3 luma = vec3(0.299f, 0.587f, 0.114f);

    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM = dot(rgbM, luma);

    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

    vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * (1.0 / 8.0)), 0.001);
    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(8.0, 8.0), max(vec2(-8.0, -8.0), dir * rcpDirMin)) * unitStep;

    vec4 rgbA = 0.5 * (texture(tex, texCoord + dir * (1.0 / 3.0 - 0.5)) + texture(tex, texCoord + dir * (2.0 / 3.0 - 0.5)));
    vec4 rgbB = rgbA * 0.5 + 0.25 * (texture(tex, texCoord + dir * 0.5) + texture(tex, texCoord + dir * -0.5));

    float lumaB = dot(rgbB.rgb, luma);

    const float alphaLerp = 0.55f;

    if ((lumaB < lumaMin) || (lumaB > lumaMax)) {
        return vec4(rgbA.rgb, mix(rgbA.a, center.a, alphaLerp));
    }

    return vec4(rgbB.rgb, mix(rgbB.a, center.a, alphaLerp));
}


vec4 nfaa(sampler2D tex, ivec2 srcPos, vec2 texCoords, vec2 uvStep) {
    vec2 upOffset = vec2(0.0, uvStep.y);
    vec2 rightOffset = vec2(uvStep.x, 0.0);


    float topHeight = lumRGB(texture(tex, texCoords + upOffset));
    float bottomHeight = lumRGB(texture(tex, texCoords - upOffset));
    float rightHeight = lumRGB(texture(tex, texCoords + rightOffset));
    float leftHeight = lumRGB(texture(tex, texCoords - rightOffset));
    float leftTopHeight = lumRGB(texture(tex, texCoords - rightOffset + upOffset));
    float leftBottomHeight = lumRGB(texture(tex, texCoords - rightOffset - upOffset));
    float rightBottomHeight = lumRGB(texture(tex, texCoords + rightOffset + upOffset));
    float rightTopHeight = lumRGB(texture(tex, texCoords + rightOffset - upOffset));

    // Normal map creation
    float sum0 = rightTopHeight + topHeight + rightBottomHeight;
    float sum1 = leftTopHeight + bottomHeight + leftBottomHeight;
    float sum2 = leftTopHeight + leftHeight + rightTopHeight;
    float sum3 = leftBottomHeight + rightHeight + rightBottomHeight;

    float vect1 = (sum1 - sum0);
    float vect2 = (sum2 - sum3);

    // Put them together and scale.
    vec2 Normal = vec2(vect1, vect2) * uvStep;

    // Color
    vec4 scene0 = texelFetch(tex, srcPos, 0);
    vec4 scene1 = texture(tex, texCoords + Normal);
    vec4 scene2 = texture(tex, texCoords - Normal);
    vec4 scene3 = texture(tex, texCoords + vec2(Normal.x, -Normal.y) * 0.5);
    vec4 scene4 = texture(tex, texCoords - vec2(Normal.x, -Normal.y) * 0.5);

    const float srcAlphaWeight = .3f;
    const float count = 5.f;
    return
        vec4(
        (
            scene0.rgb +
            scene1.rgb +
            scene2.rgb +
            scene3.rgb +
            scene4.rgb
        ) / count,

        scene0.a * srcAlphaWeight + (
            scene1.a +
            scene2.a +
            scene3.a +
            scene4.a
        ) / (count - 1.f) * (1 - srcAlphaWeight));
}

float curve(const float f, const float from, const float to) {
    if (f < from) {
        return 0.0f;
    }
    if (f > to) {
        return 1.0f;
    }
    return (f - from) / (to - from);
}

void main() {
    ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
    vec2 norstep = vec2(1) / vec2(imageSize(outputImage));
    vec2 uv = (vec2(pos) + vec2(0.5f, 0.5f)) * norstep;

//    norstep *= fScale * (1.f + curve(scale, 0.f, 5.f) * .75f);

    vec4 color = mix(fxaa(inputImage, pos, uv, norstep), nfaa(inputImage, pos, uv, norstep), 0.73f);
//    vec4 color = nfaa(inputImage, pos, uv, norstep);
//    vec4 color = texelFetch(inputImage, pos, 0);
    imageStore(outputImage, pos, color);
//    imageStore(outputImage, texelFetch(inputImage, pos, 0), color);
}
/**

const float oneThird = 1.0 / 3.0;

float favg(vec3 vec){
    return (vec.x + vec.y + vec.z) * oneThird;
}

vec4 sampleOffseted(const sampler2D tex, const vec2 texCoord, const vec2 pixelOffset, const vec2 norStep) {
    return texture(tex, texCoord + pixelOffset * norStep);
}

vec3 avg(const in vec3 value)
{
    return dot(value.xyz, vec3(oneThird, oneThird, oneThird));
}

vec4 firsPassEdgeDetect(vec2 texCoord, const vec2 norStep)
{
vec4 sCenter = sampleOffseted(inputImage, texCoord, vec2(0.0, 0.0), norStep);
vec4 sUpLeft = sampleOffseted(inputImage, texCoord, vec2(- 0.5, - 0.5), norStep);
vec4 sUpRight = sampleOffseted(inputImage, texCoord, vec2(0.5, -0.5), norStep);
vec4 sDownLeft = sampleOffseted(inputImage, texCoord, vec2(- 0.5, 0.5), norStep);
vec4 sDownRight = sampleOffseted(inputImage, texCoord, vec2(0.5, 0.5), norStep);

vec4 diff = abs(((sUpLeft + sUpRight + sDownLeft + sDownRight) * 4.0) - (sCenter * 16.0));
float edgeMask = favg(diff.xyz) * oneThird;

return vec4(sCenter.rgb, edgeMask);
}


vec4 secondPassEdgeDetectAndBlur(vec2 texCoord, const vec2 norStep) {
    // short edges
    vec4 sampleCenter = sampleOffseted(inputImage, texCoord, vec2(0.0, 0.0), norStep);
    vec4 sampleHorizNeg0 = sampleOffseted(inputImage, texCoord, vec2(- 1.5, 0.0), norStep);
    vec4 sampleHorizPos0 = sampleOffseted(inputImage, texCoord, vec2(1.5, 0.0), norStep);
    vec4 sampleVertNeg0 = sampleOffseted(inputImage, texCoord, vec2(0.0, - 1.5), norStep);
    vec4 sampleVertPos0 = sampleOffseted(inputImage, texCoord, vec2(0.0, 1.5), norStep);
    
    vec4 sumHoriz = sampleHorizNeg0 + sampleHorizPos0;
    vec4 sumVert = sampleVertNeg0 + sampleVertPos0;
    
    vec4 diffToCenterHoriz = abs(sumHoriz - (2.0 * sampleCenter)) / 2.0;
    vec4 diffToCenterVert = abs(sumHoriz - (2.0 * sampleCenter)) / 2.0;
    
    float valueEdgeHoriz = favg(diffToCenterHoriz.xyz);
    float valueEdgeVert = favg(diffToCenterVert.xyz);
    
    float edgeDetectHoriz = clamp((3.0 * valueEdgeHoriz) - 0.1, 0., 1.);
    float edgeDetectVert = clamp((3.0 * valueEdgeVert) - 0.1, 0., 1.);
    
    vec4 avgHoriz = (sumHoriz + sampleCenter) / 3.0;
    vec4 avgVert = (sumVert + sampleCenter) / 3.0;
    
    float valueHoriz = favg(avgHoriz.xyz);
    float valueVert = favg(avgVert.xyz);
    
    float blurAmountHoriz = clamp(edgeDetectHoriz / valueHoriz, 0., 1.);
    float blurAmountVert = clamp(edgeDetectVert / valueVert, 0., 1.);
    
    vec4 aaResult = mix(sampleCenter, avgHoriz, blurAmountHoriz);
    aaResult = mix(aaResult, avgVert, blurAmountVert);
    
    // long edges
    vec4 sampleVertNeg1 = sampleOffseted(inputImage, texCoord, vec2(0.0, - 3.5), norStep);
    vec4 sampleVertNeg2 = sampleOffseted(inputImage, texCoord, vec2(0.0, - 7.5), norStep);
    vec4 sampleVertPos1 = sampleOffseted(inputImage, texCoord, vec2(0.0, 3.5), norStep);
    vec4 sampleVertPos2 = sampleOffseted(inputImage, texCoord, vec2(0.0, 7.5), norStep);
    
    vec4 sampleHorizNeg1 = sampleOffseted(inputImage, texCoord, vec2(- 3.5, 0.0), norStep);
    vec4 sampleHorizNeg2 = sampleOffseted(inputImage, texCoord, vec2(- 7.5, 0.0), norStep);
    vec4 sampleHorizPos1 = sampleOffseted(inputImage, texCoord, vec2(3.5, 0.0), norStep);
    vec4 sampleHorizPos2 = sampleOffseted(inputImage, texCoord, vec2(7.5, 0.0), norStep);
    
    float pass1EdgeAvgHoriz = (sampleHorizNeg2.a + sampleHorizNeg1.a + sampleCenter.a + sampleHorizPos1.a + sampleHorizPos2.a) / 5.0;
    float pass1EdgeAvgVert = (sampleVertNeg2.a + sampleVertNeg1.a + sampleCenter.a + sampleVertPos1.a + sampleVertPos2.a) / 5.0;
    pass1EdgeAvgHoriz = clamp( pass1EdgeAvgHoriz * 2.0f - 1.0f, 0., 1.);
    pass1EdgeAvgVert = clamp(pass1EdgeAvgVert * 2.0f - 1.0f, 0., 1.);
    float longEdge = max(pass1EdgeAvgHoriz, pass1EdgeAvgVert);
    
    if (longEdge > 0) {
        vec4 avgHorizLong = (sampleHorizNeg2 + sampleHorizNeg1 + sampleCenter + sampleHorizPos1 + sampleHorizPos2) / 5.0;
        vec4 avgVertLong = (sampleVertNeg2 + sampleVertNeg1 + sampleCenter + sampleVertPos1 + sampleVertPos2 ) / 5.0;
        float valueHorizLong = favg(avgHorizLong.xyz);
        float valueVertLong = favg(avgVertLong.xyz);
        
        vec4 sampleLeft = sampleOffseted(inputImage, texCoord, vec2(- 1.0, 0.0), norStep);
        vec4 sampleRight = sampleOffseted(inputImage, texCoord, vec2(1.0, 0.0), norStep);
        vec4 sampleUp = sampleOffseted(inputImage, texCoord, vec2(0.0, - 1.0), norStep);
        vec4 sampleDown = sampleOffseted(inputImage, texCoord, vec2(0.0, 1.0), norStep);
        
        float valueCenter = favg(sampleCenter.xyz);
        float valueLeft = favg(sampleLeft.xyz);
        float valueRight = favg(sampleRight.xyz);
        float valueTop = favg(sampleUp.xyz);
        float valueBottom = favg(sampleDown.xyz);
        
        vec4 diffToCenter = valueCenter - vec4(valueLeft, valueTop, valueRight, valueBottom);
        float blurAmountLeft = clamp(0.0 + (valueVertLong - valueLeft) / diffToCenter.x, 0., 1.);
        float blurAmountUp = clamp(0.0 + (valueHorizLong - valueTop) / diffToCenter.y, 0., 1.);
        float blurAmountRight = clamp(1.0 + (valueVertLong - valueCenter) / diffToCenter.z, 0., 1.);
        float blurAmountDown = clamp(1.0 + ( valueHorizLong - valueCenter) / diffToCenter.w, 0., 1.);
        
        vec4 blurAmounts = vec4(blurAmountLeft, blurAmountRight, blurAmountUp, blurAmountDown);
        blurAmounts = (blurAmounts == vec4(0.0, 0.0, 0.0, 0.0)) ? vec4(1.0, 1.0, 1.0, 1.0): blurAmounts;
        
        vec4 longBlurHoriz = mix(sampleLeft, sampleCenter, blurAmounts.x);
        longBlurHoriz = mix(sampleRight, longBlurHoriz, blurAmounts.y);
        vec4 longBlurVert = mix(sampleUp, sampleCenter, blurAmounts.z);
        longBlurVert = mix(sampleDown, longBlurVert, blurAmounts.w);
        
        aaResult = mix(aaResult, longBlurHoriz, pass1EdgeAvgVert);
        aaResult = mix(aaResult, longBlurVert, pass1EdgeAvgHoriz);
        }
    
    return vec4(aaResult.rgb, 1.0f);
}
*/
